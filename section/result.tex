\section{Preliminary results}

\begin{figure}[!ht]
    \includesvg[width=\linewidth]{figure/combined}
    \caption{The query execution time distribution (the upper graph) and the number of HTTP requests (the lower graph).
    The results of our approach are in blue and the state of the art (type index with LDP) in red.
    The results have been generated with 50 repetitions and a timeout of 6000 ms. 
    The queries are denoted with first the initial of the query template (e.g., S1 for interactive-\textbf{s}hort-\textbf{1}), and the version
     of the concrete query (e.g., V0). 
     Values not present in the plot indicate that the query timeout before the end of the execution.
    }
    \label{fig:result}
\end{figure}

\sepfootnotecontent{impl}{The algorithm is available at the following link \href{https://github.com/constraintAutomaton/query-shape-detection}{https://t.ly/4sTcI} 
and an integration inside the engine \href{https://github.com/comunica/comunica}{Comunica} at this link 
\href{https://github.com/constraintAutomaton/comunica-feature-link-traversal/tree/feature/shapeIndex}{https://t.ly/U2GcK}.}

\sepfootnotecontent{benchmark}{We executed interactive-short 1 and 5, interactive-discover 1,3-7 and interactive-complex 8 with
a modified benchmark. The results of the complex queries were omitted because the two approaches were not able to execute them before the timeout.
This benchmark adds a complete shape index inside each "pod" of the dataset using
a \href{https://github.com/constraintAutomaton/rdf-dataset-fragmenter.js/tree/feature/shapeIndex}{generator} accessible via the hypermedia link.
The implementation of the benchmark and complementary results (for instance analysis of the statistical significance) are availabe at the following link 
\href{https://github.com/constraintAutomaton/amw_shape_index_results}{https://t.ly/Insu5}.}

For early evaluation, we implemented the containment algorithm described in the previous section.
An open implementation of the algorithm and an integration in the query engine Comunica \cite{taelman_iswc_resources_comunica_2018} is available online \sepfootnote{impl}.
In its current state, the implementation doesn't support 
\href{https://www.w3.org/TR/sparql11-query/#propertypaths}{SPARQL property paths} and nested queries.
We use the benchmark Solidbench \cite{Taelman2023} to compare our approach with the current state of the art 
(a combination of the type index and the \href{https://www.w3.org/TR/ldp/}{LDP specification} as structural assumptions \rt{Neither of these have been explained yet!!}) \cite{Taelman2023}.
To accommodate the limitation of our implementation we use a subset of the queries of Solidbench.
The benchmark with complementary result is open source and available online \sepfootnote{benchmark}.
We executed each query 50 times with a timeout of 1 minute (6,000 ms).
The results are presented in Figure \ref{fig:result}.
In Figure \ref{fig:result},  \rt{Let's start with the good news first} we notice that in the worst cases, our approach (in blue) has similar query execution times with a 
distribution tending to be lower than the state of the art (with exeption to D3V3 and D3V4).
Furthermore, their variances tend to be lower compared to their counterpart. 
A possible explanation is that the execution time of HTTP requests is not constant and can be unpredictable \cite{hartig2016walking}
which could lead to an increase in variance.
This observation not only has potential implications for the reliability of multiple executions in terms of time
but also in terms of performance for single execution in unstable networks where the server might take longer times to respond. 
As for the number of HTTP requests our approach reliably executes less of them, as expected because no
queries target (implicitly) each file of a user.
In the best-case scenario the percentage of the reduction can be as high as 80\% (D1V3 and S1V3) for the execution time 
and 97\% (S1V3) for the number of HTTP requests.
However, there is not a direct correlation between the reduction of execution time and HTTP requests (e.g., the ratio 
between our approach and the state of the art of HTTP request by the ratio of execution time for D1V3 is 0.5 compared to 0.15 for S1V3).
This hints at the results from the state of the art \cite{Taelman2023} proposing that the query plan is the bottleneck for some queries in this environment,
but the overhead of the containment calculation could also be a contributing factor to the current results.

  