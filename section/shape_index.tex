\section{Shape index and query shape containment}

We define a SI as a set of mapping between RDF shapes and sets of resources.
Additionally, the SI has an associated domain of action
and a flag indicating if each resource in the domain is bound by a shape. 
We refer to a SI with this flag as a complete shape index.
In a SI when a shape is in relation to a set of RDF resources then the shape must validate those resources.
Furthermore, every set of triples respecting the shape in the domain must be located inside one resource of the set.
Lastly, if the shape has an RDF class constraint
then every set of triples associated with that class must respect the shape.

An RDF shape describes the predicates an RDF subject must be linked to with associated information about
their cardinality and a constraint binding the linked RDF objects.
RDF shapes can be transformed into a SPARQL query, but
in this short paper we are not going to provide proof for this proposition, however,
\citeauthor{Delva2021} provide an intuition by demonstrating how to extract 
a subgraph from an RDF graph using RDF shapes as a query language.
Considering a query $Q_p$ a subquery of the query provided by the user $Q$
where $Q_p$ is created from a star pattern and its dependencies, and $Q_s$ formed by the transformation of a shape inside of the SI
into a query then if  $Q_p$ is contained inside $Q_s$ the associated 
set of documents can contribute to the query result.
Often $Q_p$ is contained inside multiple $Q_s$ due to the reuse of vocabulary terms,
in those instances, the engine considers every document associated with those shapes
as potential sources of solutions.
If every $Q_p \in Q$ are contained by a shape of the SI then we know before the request of the whole domain
where potential solution can be accessed, thus the engine can safely adapt the lookup policy to prune every links from the rest of the domain.
Above is the best-case scenario but other propositions are necessary to solve the general problem.
If one of the shapes is open then it will always be necessary to visit the set of documents associated
with it, unless negative predicate are defined in the shape.
If the SI is complete and some $Q_p$ are not contained inside a $Q_s$ then the engine has to visit
every set of documents where $Q_p$ has a partial binding with an associated $Q_s$.
In a similar case where the SI is not complete then it is necessary to visit every document in the bounded yet unknown domain with exception to those
where the $Q_p$s have no partial binding with the $Q_s$.
In those two cases, the following heuristic can be used.
If $Q_p$ and $Q_s$ are bound by the same RDF class then we only consider the set of documents of $Q_s$.
We use this heuristic because of the definition of the SI presented earlier.
The SI is defined that way to reduce the chance of potential contradiction between RDF class and shape.
This proposition supposes that at least in the context of the query there are no contradictions between the
definition of the shapes, classes ,and the implicit data model (when considering the joining of triple patterns) the user request.