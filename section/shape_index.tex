\section{Shape index and query shape containment}

\rt{I would first briefly explain the basics of Solid and data pods. I know your approach is not tied to Solid, but I would give Solid as an example of how it can be used. Otherwise things are too abstract to understand. But definitely say that your approach can be applied outside of Solid as well.}

We define a Shape Index (SI) as a set of mappings between RDF shapes and sets of resources.
Additionally, an SI has an associated domain of action
and a flag indicating if each resource in the domain is bound by a shape. 
We refer to a SI with this flag as a \emph{complete} Shape Index.
In a SI when a shape is in relation to a set of RDF resources then the shape must validate those resources.
Furthermore, every set of triples respecting the shape in the domain must be located inside one resource of the set.
Lastly, if the shape has an RDF class constraint
then every set of triples associated with that class must respect the shape. \rt{Doesn't this follow from the fact that triples must be valid to the shape?}

\rt{The next paragraph is very difficult to follow. I'm think you're trying to explain your query containment approach and how you can prune links, but I don't understand it, because the text goes a bit all over the place. I suggest restructuring the paragraph, by first saying that you prune links using shape-query containment. Then, say that shape-query containment has not been investigated in detail (but mention Delva2021). Then, explain your algorithm in different steps, and first give a high-level overview of each step (optionally in pseudocode). And if there's not enough room to properly explain it, better to keep it high-level, and keep the details for the next paper.}
\rt{What could even be more helpful for this paper, is an illustration of a shape index in practise, and intuitively explaining how to use it for a specific query. This is just a short paper, so we don't need to explain our algorithm in detail yet.}
An RDF shape describes the predicates an RDF subject must be associated with complementary information about
the relative cardinality of the predicates and a constraint binding the associated RDF objects.
RDF shapes can be transformed into a SPARQL query, but
in this short paper we are not going to provide a proof for this proposition, however,
\citeauthor{Delva2021} provide an intuition by demonstrating how to extract 
a subgraph from an RDF graph using RDF shapes as a query language.
Considering a query $Q_p$ a subquery of the query provided by the user $Q$
where $Q_p$ is created from a star pattern and its dependencies, and $Q_s$ formed by the transformation of a shape inside of the SI
into a query then if  $Q_p$ is contained inside $Q_s$ the associated 
set of documents exclusively contribute to the query result of $Q_p$ in the domain of the SI.
Often $Q_p$ is contained inside multiple $Q_s$ due to the reuse of vocabulary terms,
in those instances all the documents associated with the $Q_s$s are exclusive sources of solution in relation to the domain.
If every $Q_p \in Q$ are contained by a shape of the SI then we know before the request of the whole domain
where potential solutions can be accessed, thus the engine can safely adapt the lookup policy to prune every links from the rest of the domain.
Above is the best-case scenario but other propositions are necessary to solve the general problem.
If one of the shapes is open then it will always be necessary to visit the set of documents associated
with it, unless negative predicates invalidate the bindings.
If the SI is complete and some $Q_p$ are not contained inside a $Q_s$ then the engine has to visit
every set of documents where $Q_p$ has a partial binding with an associated $Q_s$.
In a similar case where the SI is not complete then it is necessary to visit every document in the bounded yet not necessarly known domain 
with exception to those where the $Q_p$s have no partial binding with the $Q_s$.
In those two cases, the following heuristic can be used.
If $Q_p$ and $Q_s$ are bound by the same RDF class then we only consider the set of documents of $Q_s$.
We use this heuristic because of the definition of the SI presented earlier.
The SI is defined that way to reduce the chance of potential contradiction between RDF classes and shapes.
This proposition supposes that at least in the context of the query there are no contradictions between the
definition of the shapes, classes ,and the implicit data model (when considering the joining of triple patterns) the user request.